<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM学习</title>
      <link href="/2022/11/10/jvm/"/>
      <url>/2022/11/10/jvm/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本博客是根据解密<a href="https://www.bilibili.com/video/BV1yE411Z7AP/?vd_source=bb964513be8f40f1cad91aee35f32b3b">JVM【黑马程序员出品】</a>教学视频学习时，所做的笔记</p><hr><h1 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>JVM JRE JDK的区别</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" srcset="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" alt=""><hr><h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><a data-fancybox="images" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" srcset="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt=""></a></p><h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用于保存JVM中下一条所要执行的指令的地址</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序     计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>每个线程运行需要的内存空间，称为虚拟机栈</p></li><li><p>每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</p></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>method1();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/JVM/20200608150534.png"></p><p>在控制台中可以看到，主类中的方法进入虚拟机栈的时候，复合栈的特点</p><h3 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h3><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会弹出栈。所<br>以无需通过垃圾回收机制回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li><strong>不是</strong>。 因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就<br> 会越少</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题内存溢出</li></ul></li></ul><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，栈帧过多（无限递归）</li><li>每个栈帧所占用过大</li></ul><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是<br> 哪个线程占用CPU过高</li><li><strong>jstack 进程id <strong>通过查看进程中的线程的nid，刚才通过ps命令看到的tid来</strong>对比定位</strong>注意jstack查找<br> 出的线程id是<strong>16进制的，需要转换</strong></li></ul></li></ul><h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>通过new关键字，创建的对象都会被放在堆内存</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>所有线程共享，堆内存中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/img/JVM/20200608150547.png"></p><h3 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul><li>1.8以前会导致永久代内存溢出（1.8以前是使用永久代  使用jvm内存）</li><li>1.8以后会导致元空间内存溢出（1.8以后是使用元空间  使用本地内存）</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>位置</strong></p><ul><li>Java6和6之前，常量池是存放在方法区（永久代）中的。</li><li>Java7，将常量池是存放到了堆中。</li><li>Java8之后，取消了整个永久代区域，取而代之的是元空间。运行时常量池和静态常量池存放在元空间<br>中，而字符串常量池依然存放在堆中。</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法<br>名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li><strong>常量池是.class文件中的，当该*类被加载以后，它的常量池信息就会放入运行时常量池，并把里面<br>的符号地址变为真实地址</strong></li></ul></li></ul><h3 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h3><h4 id="字符串池StringTable"><a href="#字符串池StringTable" class="headerlink" title="字符串池StringTable"></a>字符串池StringTable</h4><p><strong>位置</strong></p><ul><li>1.7之前在永久代方法区中</li><li>1.7之后在堆内存中</li></ul><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li><li>注意：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的元素不重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br><span class="hljs-number">2</span>: astore_1<br><span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br><span class="hljs-number">5</span>: astore_2<br><span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br><span class="hljs-number">8</span>: astore_3<br><span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong> (hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p><strong>使用拼接字符串变量对象创建字符串的过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">20</span>: aload_2<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的值和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><p>使用拼接字符串常量对象的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b;<br><span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ab3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">   Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">20</span>: aload_2<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span><br>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span><br>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><ul><li>使用拼接字符串常量的方法来创建新的字符串时，因为内容是常量，javac在编译期会进行优化，结果<br>已在编译期确定为ab，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以<br>进行的操作和 ab &#x3D; “ab” 一致。</li><li>使用拼接字符串变量的方法来创建新的字符串时，因为内容是变量，只能在运行期确定它的值，所以需<br>要使用StringBuilder来创建</li></ul><h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><p>1.6以前：<br>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回串池中的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><p>1.6以后：<br>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中的字符串对象</strong></p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><h2 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h2><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放<br><img src="/img/JVM/20200608150750.png"></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象为起点的引用链找到该对象，找不到，表示可以<br>回收</li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><p><img src="/img/JVM/20200608150800.png"></p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>只有GC Root都不引用该对象时，才会回收强引用对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h5 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用，需要使用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br><br><span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br><span class="hljs-keyword">while</span>(poll != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>list.remove(poll);<br><span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>poll = queue.poll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大概思路为</strong>：查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>只有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收<br><strong>弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference</strong></li></ul><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是释放直接内存所分配的内存，当引用的对象ByteBuffer被垃圾回收以后，虚引用对<br>象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。<br>这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它<br>所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h4 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h4><ul><li>软引用和弱引用可以配合引用队列<ul><li>在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软&#x2F;弱引用对象</li></ul></li><li>虚引用和终结器引用必须配合引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p><img src="/img/JVM/20200608150813.png"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内<br>存的时候，会直接覆盖这段内存</li></ul><p>缺点：容易产生大量的内存碎片，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p><img src="/img/JVM/20200608150827.png"><br>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h3 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h3><p><img src="/img/JVM/20200608150842.png"><img src="/img/JVM/20200608150856.png"><img src="/img/JVM/20200608150907.png"><img src="/img/JVM/20200608150919.png"><br>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h2 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h2><p><img src="/img/JVM/20200608150931.png"></p><h3 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h3><p>新创建的对象都被放在了新生代的伊甸园中<br><img src="/img/JVM/20200608150939.png"><br>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 Minor GC<br>Minor GC 会将伊甸园和幸存区FROM存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换两个幸存区</p><p><img src="/img/JVM/20200608150946.png"><img src="/img/JVM/20200608150955.png"><img src="/img/JVM/20200608151002.png"></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</p><p><img src="/img/JVM/20200608151010.png"></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被放入老年代中</p><p><img src="/img/JVM/20200608151018.png"></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发Full GC，扫描新生代和老年代中所有不再使用的对象并回收</p><h3 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h3><h4 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h4><p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代</p><h4 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h4><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常</p><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><p><img src="/img/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Serial收集器是最基本、发展历史最久的收集器，这个收集器是采用复制算法的单线程的收集器</p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>从概念上来看，我们需要注意Serial收集器的两个特点：一个是采用<strong>复制算法</strong>，另外一个是<strong>单线程收集</strong>。</p><h4 id="单线程的收集器"><a href="#单线程的收集器" class="headerlink" title="单线程的收集器"></a>单线程的收集器</h4><p>单线程一方面意味着他只会使用一个 CPU 或者一条线程去完成垃圾收集工作，另一方面也意味着他进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。</p><p><strong>Serial 收集器运行过程如下图所示</strong>：<br><img src="/img/JVM/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h3 id="Parnew收集器"><a href="#Parnew收集器" class="headerlink" title="Parnew收集器"></a>Parnew收集器</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>Parnew 收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样，但是他却是 Server 模式下的虚拟机首选的新生代收集器</p><h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h4><p>从概念上来看，我们需要注意Parnew收集器的两个特点：一个是采用<strong>复制算法</strong>，另外一个是<strong>多线程收集</strong>。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。CMS 收集器第一次实现了让垃圾收集器与用户线程基本上同时工作；<br>Parnew 收集器默认开启的收集线程数与 CPU 数量相同，在 CPU 数量非常多的情况下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。 </p><p><strong>Parnew 收集器运行过程如下图所示</strong>：<br><img src="/img/JVM/Parnew%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h3 id="Parnew收集器-1"><a href="#Parnew收集器-1" class="headerlink" title="Parnew收集器"></a>Parnew收集器</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>Parallel Scavenge 收集器也是一个新生代收集器，也采用了复制算法，也是并行的多线程收集器。Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。Parallel Scavenge 收集器是虚拟机运行在 Server 模式下的默认垃圾收集器。被称为“吞吐量优先收集器”。</p><h4 id="Tips-2"><a href="#Tips-2" class="headerlink" title="Tips"></a>Tips</h4><p>从概念上来看，我们需要注意Parallel Scavenge收集器的三个个特点：一个是采用复制算法，一个是多线程收集，一个是达到控制吞吐量的目标。</p><p><strong>Parallel Scavenge 收集器运行过程同 Parnew 收集器一样</strong><br><img src="/img/JVM/ParallelScavenge%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h4 id="控制吞吐量"><a href="#控制吞吐量" class="headerlink" title="控制吞吐量"></a>控制吞吐量</h4><p>CMS 等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是 CPU 用于运行用户代码时间与 CPU 总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）。</p><h4 id="吞吐量参数介绍"><a href="#吞吐量参数介绍" class="headerlink" title="吞吐量参数介绍"></a>吞吐量参数介绍</h4><p>虚拟机提供了-XX：MaxGCPauseMills 和 -XX：GCTimeRatio 两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC 停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，Parallel Scavenge 收集器也被称为“吞吐量优先收集器”。<br><strong>Parallel Scavenge 收集器有一个参数 -XX：UseAdaptiveSizePolicy 参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden 区和 Survivor 参数等细节参数了，虚拟机会根据当前系统的运行情况以及性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。<br>如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，可以使用 Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成。</strong></p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p>Serial Old 收集器同样是一个<strong>单线程收集器</strong>，作用于老年代，使用<strong>“标记-整理算法”</strong>，这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</p><p><strong>Serial Old 收集器运行过程如图所示：</strong><br><img src="/img/JVM/SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理算法”进行垃圾回收。<br>这个收集器在 JDK 1.6 之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge收集器+Parallel Old收集器 的组合。</p><p><strong>Parallel Scavenge 收集器+Parallel Old 收集器 的组合运行过程如下图所示：</strong><br><img src="/img/JVM/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><p>CMS（Conrrurent Mark Sweep，连续标记扫描）收集器是以获取最短回收停顿时间为目标的收集器。使用标记-清除算法。</p><h4 id="收集步骤："><a href="#收集步骤：" class="headerlink" title="收集步骤："></a>收集步骤：</h4><ul><li>初始标记：标记 GCRoots 能直接关联到的对象，时间很短；</li><li>并发标记：进行 GCRoots Tracing（可达性分析）过程，时间很长；</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长；</li><li>并发清除：回收内存空间，时间很长。其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。</li></ul><p><strong>CMS 收集器运行过程如下图所示:</strong><br><img src="/img/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><h4 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h4><p>G1 是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉 JDK1.5 中发布的 CMS 收集器。</p><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p> <strong>a.并发和并行</strong>：使用多个 CPU 来缩短 Stop The World 停顿时间，与用户线程并发执行；<br> <strong>b.分代收集</strong>：独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多<br>     次 GC 的旧对象以获取更好的收集效果；<br> <strong>c.空间整合</strong>：基于标记-整理算法，无内存碎片产生；<br> <strong>d.可预测的停顿</strong>：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段<br>     内，消耗在垃圾收集器上的时间不得超过N毫秒。</p><blockquote><p>在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region 的集合。</p></blockquote><p><strong>G1收集器运行过程如下图所示:</strong><br><img src="/img/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><h4 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h4><p><img src="/img/JVM/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png"><br>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW<br><img src="/img/JVM/YoungCollection1.png"><img src="/img/JVM/YoungCollection2.png"><img src="/img/JVM/YoungCollection3.png"></li></ul><h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h4><p>CM：并发标记</p><ul><li>在 Young GC 时会对 GC Root 进行初始标记</li><li>在老年代占用堆内存的比例达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定<br><img src="/img/JVM/YoungCollection+CM.png"></li></ul><h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li>拷贝存活<br>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</li></ul><p>问：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，<strong>会回收最有价值的老年代（回收后，能够得到更多内存）</strong></p><p><img src="/img/JVM/MixedCollection.png"></p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h4 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h4><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><img src="/img/JVM/20200608151211.png"></p><ul><li><p>卡表与Remembered Set</p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li><p>在引用变更时通过post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads 更新 Remembered Set<br><img src="/img/JVM/20200608151222.png"></p></li></ul><p><strong>G1任然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合</strong><br><img src="/img/JVM/a0ab2093282945a89ab10ac8ad828f3f.png"></p><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>顾名思义，用三种颜色进行标记</p><ul><li><p>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达(白色对象会被当成垃圾对象)。</p></li><li><p>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象(黑色对象不会当成垃圾对象)。</p></li><li><p>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。</p></li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><pre><code class="hljs">1. 初始时，全部对象都是白色的2. GC Roots直接引用的对象变成灰色3. 从灰色集合中获取元素：   3.1.  将本对象直接引用的对象标记为灰色   3.2.  将本对象标记为黑色4. 重复步骤3，直到灰色的对象集合变为空5. 结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</code></pre><blockquote><p>当Stop The Word时，对象间的引用是不会发生变化的，因为用户线程中断了，可以轻松完成标记，但是在并发标记的时候，标记期间用户线程还在跑，对象间的引用可能发生变化，多标和漏标的情况就可能会发生</p></blockquote><h4 id="多标-又叫浮动垃圾"><a href="#多标-又叫浮动垃圾" class="headerlink" title="多标(又叫浮动垃圾)"></a>多标(又叫浮动垃圾)</h4><p>假设此时我们遍历到了D对象，此时D被标记成了灰色<br><img src="/img/JVM/%E5%A4%9A%E6%A0%871.png"></p><p>此时线程发生B取消了对D的引用<br><img src="/img/JVM/%E5%A4%9A%E6%A0%872.png"></p><p>这时候B-&gt;D的引用没了，D应该是白色，但是因为先前D已经被标记成灰色了，所以D对象仍然会被当成存活对象遍历下去。最终结果：这部分对象仍然会被标记为存活对象，本轮GC不会回收他们的内存。这部分因为并发而造成的本应该回收但是没有回收的对象被称为”浮动垃圾”，我们稍微一想也能想到，<strong>浮动垃圾不会影响应用程序的正确性，只需要等到下一轮GC到来就会被回收了。</strong></p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><h4 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标(读写屏障)"></a>漏标(读写屏障)</h4><p>假设GC线程已经遍历到D对象，此时D被标记为灰色<br><img src="/img/JVM/%E6%BC%8F%E6%A0%871.png"></p><p>但是此时有代码执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">E</span> <span class="hljs-operator">=</span> D.next;<br>D.next = <span class="hljs-literal">null</span>;<br>B.next = E;<br></code></pre></td></tr></table></figure><p> 变成了这样<br><img src="/img/JVM/%E6%BC%8F%E6%A0%872.png"></p><p>此时D到E的引用消失，B生成了对E的引用。当GC线程继续时，因为D已经没有了对E的引用，所以不会遍历到E，E也就不会标志为灰色，同时B已经标志为黑色了，不会再被遍历，那么也就导致E一直是白色的，最后被当成垃圾处理，这显然与事实不符，E是可打的，但是因为并发的影响漏标了E，使得E被垃圾回收，明显影响了应用程序的正确性，这是不可接受的。</p><p>分析一下，漏标只有同时慢则一下两个条件时才会发生：</p><ol><li><p>灰色对象断开了白色对象的引用</p></li><li><p>黑色对象重新引用了该白色对象</p></li></ol><h4 id="一、写屏障-阻止第二步和第三步"><a href="#一、写屏障-阻止第二步和第三步" class="headerlink" title="一、写屏障(阻止第二步和第三步)"></a>一、写屏障(阻止第二步和第三步)</h4><h5 id="1-写屏障-SATB"><a href="#1-写屏障-SATB" class="headerlink" title="1.写屏障 + SATB"></a>1.写屏障 + SATB</h5><p>当对象D的引用发生变化时，利用写屏障，将D原来的引用对象记录下来，这样可以尝试保留开始时的对象图，保证标记依然 按照原本的路线走</p><h5 id="2-写屏障-增量更新"><a href="#2-写屏障-增量更新" class="headerlink" title="2.写屏障 + 增量更新"></a>2.写屏障 + 增量更新</h5><p>当对象B的引用发生变化时，利用写屏障，将B新的引用对象E记录下来</p><p><strong>即当有新的引用插入进来时，记录下新的引用</strong></p><p>这种思路不要求保留原始对象图，而是针对新的引用记录下来等待遍历即增量更新</p><h4 id="二、读屏障-阻止第一步"><a href="#二、读屏障-阻止第一步" class="headerlink" title="二、读屏障(阻止第一步)"></a>二、读屏障(阻止第一步)</h4><p>读屏障针对第一步，当读取引用对象的时候，一律记录下来，显然这种方法非常保守，但是安全。</p><blockquote><p>将记录下的引用遍历就是了<br>在现代的垃圾回收器当中可达性分析算法的垃圾回收器几乎都借鉴了三色标记法的思想。</p><p>在Java HotSpot VM中</p><p>CMS采用的是：写屏障 + 增量更新</p><p>G1采用的是：写屏障 + SATB</p></blockquote><h1 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h1><p><img src="/img/JVM/20200608151300.png"></p><h2 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h2><h2 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h2><h2 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h2><h2 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li></ul><p><img src="/img/JVM/20200611205050.png"></p><ul><li>instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在堆内存中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证类是否符合 JVM规范，安全性检查</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池中的符号引用解析为直接引用</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器clinit()方法的过程，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong><br>编译器收集的顺序是由<strong>语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>，如</p><p><img src="/img/JVM/20201118204542.png"></p><h4 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h4><p><strong>类的初始化的懒惰的</strong></p><p>以下情况会初始化：</p><ul><li>main 方法所在的类，总会被首先初始化  </li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化：</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</strong></p><p>以JDK 8为例</p><table><thead><tr><th align="left">名称</th><th align="left">加载的类</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Bootstrap ClassLoader</strong>（启动类加载器）</td><td align="left">**JAVA_HOME&#x2F;jre&#x2F;lib **</td><td align="left">无法直接访问</td></tr><tr><td align="left"><strong>Extension ClassLoader</strong>(拓展类加载器)*</td><td align="left"><strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong></td><td align="left">上级为<strong>Bootstrap</strong>，显示为<strong>null</strong></td></tr><tr><td align="left"><strong>Application ClassLoader</strong>(应用程序类加载器)</td><td align="left"><strong>classpath</strong></td><td align="left">上级为<strong>Extension</strong></td></tr><tr><td align="left">自定义类加载器</td><td align="left">自定义</td><td align="left">上级为<strong>Application</strong></td></tr></tbody></table><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h3 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h3><p>如果classpath和JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法</li><li>不是重写loadClass方法，否则不会走双亲委派机制</li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h3 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h3><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h2 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/10/hello-world/"/>
      <url>/2022/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
